Suppose we don’t sample the historical prices, anybody can call SellRewards at any time. 
And suppose the UST/stSOL pool is at 1 UST = 1 stSOL and there is no activity on it

Then as an adversary, I can do, in a single transaction:

* Buy UST from the pool until it’s at 1 UST = 1.1 stSOL
* Call SellRewards, which also buys UST, say until 1 UST = 1.12 stSOL.
* Sell my UST to the pool again, and now I made some profit because I get more stSOL than I put in

So we add the historical price sampling, and say we set a min_out_bps of 9900, so 99.0%

Let’s say the five FetchPrice calls were not sandwiched (yet), they all observe 1 UST = 1 stSOL

Now we get to the SellRewards, and we want to sandwich it

But the program will now use min_out = median(historical stSOL price) * st_sol_to_sell * min_out_bps/1e4, 
so we use an exchange rate of at least 0.99 UST per stSOL. 
If somebody sandwiches us and changes the pool price to 1 UST = 1.12 stSOL <=> 0.89 UST = 1 stSOL, then the swap will fail, 
because it can only succeed if we get at least 0.99 UST per stSOL

Now we prevented the sandwich

How can an attacker still make the sandwich succeed? The st_sol_to_sell is just a property of the instance, not under their control. 
min_out_bps is a configuration variable, only the multisig can change it. 
The one thing that the attacker _might_ influence, is the historical stSOL price

It’s computed as median(price[0], price[1], price[2], price[3], price[4]). If we have 4 honest values here (say 1 UST = 1 stSOL) 
and you want to change the outcome to 1 UST = 1.12 stSOL ... just changing one of the samples will not change the median, 
if we sort we get [1.0, 1.0, 1.0, 1.0, 1.12].

So the median is still 1.0

(And an attacker can control one of these values by sandwiching the FetchPrice)

Even if you sandwich two of them, it will be [1.0, 1.0, 1.0, 1.12, 1.12], median remains unaffected

You need to sandwich a third one, then we get [1.0, 1.0, 1.12, 1.12, 1.12], and now you did manage to change the median

So now you can call SellRewards and sandwich that one as well, and it will use 0.89 UST = 1 stSOL to compute the min_out

But to pull that off, you needed to sandwich three of the FetchPrice calls *and* the final SellRewards

Which means you paid swap fees four times

And also, if you compete with an honest maintainer who is also trying to call FetchPrice and SellRewards, 
and you have a probability p of winning this race

Then the probability of winning the final one and at least three prior ones is 
p * ((5 choose 3)(p^3)(1-p)^2 + (5 choose 4)(p^4)(1-p) + p^5)

If p per call is 0.5, then the probability to pull it off is only 0.25

If you only have a 33% chance to pull it off per call, then the total probability to succeed is 0.068